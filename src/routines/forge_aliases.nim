## Common routines for forge aliases
##
## Copyright (C) 2025 Trayambak Rai (xtrayambak at disroot dot org)
import std/options
import pkg/[results, shakar, url]

type
  ForgeAliasError* = object of ValueError
  NotAForgeAlias* = object of ForgeAliasError

  InvalidForgeAlias* = object of ForgeAliasError
    url*: string

func isForgeAlias*(url: URL): bool {.inline, raises: [].} =
  url.hasOpaquePath

func expandForgeUrl*(url: URL): string =
  if not url.hasOpaquePath:
    raise newException(
      NotAForgeAlias, "<red>" & $url & "<reset> is not a valid forge alias"
    )

  let expandedUrl =
    case url.scheme
    of "gh", "github":
      some("https://github.com/" & url.pathname)
    of "srht", "shart", "sourcehut":
      # Fun fact: I managed to sneak "shart" into Nimble,
      # and it still lives on there to this day :^)
      #
      # https://man.sr.ht/sr.ht/#how-do-you-writepronounce-sourcehut
      some("https://git.sr.ht/" & url.pathname)
    of "gl", "gitlab":
      some("https://gitlab.com/" & url.pathname)
    else:
      none(string) # We're not aware of whatever this is. Feel free to add more cases.

  if !expandedUrl:
    var exc = newException(InvalidForgeAlias, "")
    exc.url = url.serialize()

    raise move(exc)

  # As a sanity check, we might as well
  # parse our generated URL to ensure that it
  # isn't malformed in any way.
  let validation = tryParseUrl(&expandedUrl)
  if isErr(validation):
    raise newException(
      ForgeAliasError,
      "BUG: Cannot parse URL generated by addDependencyForgeAlias(): " &
        $validation.error(),
    )

  &expandedUrl
